#!/bin/bash
#
# SPDX-License-Identifier: GPL-2.0-or-later
#
# Copyright (C) 2022 Western Digital Corporation or its affiliates.
#

function test_num()
{
        basename "$1" .sh
}

function exit_skip()
{
	exit 2
}

function exit_warning()
{
	echo "$1"
	exit 3
}

function exit_failed()
{
	echo "$1"
	exit 1
}

function require_lib()
{
	if [ "$(ldconfig -p | grep -c "$1")" == 0 ]; then
		echo "$1 not found."
		echo "Installing $1 is required to run tests."
		exit 1
	fi
}

function require_program()
{
	[[ $(type -P "$1") ]] || \
		{
			echo "$1 not found."
			echo "Installing $1 is required to run tests."
			exit 1
		}
}

function have_module()
{
	modinfo "$1" > /dev/null 2>&1
	[ $? == 0 ]
}

function have_dev()
{
	[ -e "/dev/$1" ]
}

function min()
{
	local a=$1
	local b=$2

	echo $((a < b ? a : b))
}

function max()
{
	local a=$1
	local b=$2

	echo $((a > b ? a : b))
}

function devname()
{
	basename "$(realpath $1)"
}

function devtype()
{
	local dev="$(realpath $1)"
	local bdev="$(basename ${dev})"

	zoned="$(cat /sys/block/${bdev}/queue/zoned)"
	if [ "${zoned}" == "none" ]; then
		echo "cmr"
	else
		echo "smr"
	fi
}

function devname()
{
	basename "$(realpath $1)"
}

function dev_capacity()
{
	local dev="$(realpath $1)"
	local bdev="$(basename ${dev})"

	echo "$(cat /sys/block/${bdev}/size)"
}

function dev_fw()
{
	local dev="$(realpath $1)"
	local bdev="$(basename ${dev})"

	cat /sys/block/${bdev}/device/rev
}

function dev_has_bad_fw()
{
	local devfw="$(dev_fw "$1")"
	declare -a badfw=("0BM2" "WTC0")

	if [ "${force_tests}" == "1" ]; then
		false
		return
	fi

	for fw in "${badfw[@]}"; do
		if [ "$devfw" == "$fw" ]; then
			true
			return
		fi
	done

	false
}

function dev_is_ata()
{
	local dev="$(realpath $1)"
	local bdev="$(basename ${dev})"
	local val=$(lsscsi | grep "${bdev}" | grep -c "ATA")

	[ "${val}" == "1" ]
}

function create_nullb()
{
	local n=0

	modprobe null_blk nr_devices=0

	while [ 1 ]; do
		if [ ! -b "/dev/nullb$n" ]; then
			break
		fi
		n=$(( n + 1 ))
	done

	mkdir /sys/kernel/config/nullb/nullb$n
	echo 0 > /sys/kernel/config/nullb/nullb$n/zoned
	echo 1 > /sys/kernel/config/nullb/nullb$n/power

	echo "$n"
}

function destroy_nullb()
{
        local n=$1

	echo 0 > /sys/kernel/config/nullb/nullb$n/power
	rmdir /sys/kernel/config/nullb/nullb$n

	rmmod null_blk >> /dev/null 2>&1
}

function get_desired_scheduler()
{
	local dev="$(realpath $1)"
	local bdev="$(basename ${dev})"

	if [ "$(devtype ${dev})" == "cmr" ]; then
		echo "none"
	else
		echo "mq-deadline"
	fi
}

function dev_scheduler()
{
	local dev="$(realpath $1)"
	local bdev="$(basename ${dev})"
	local sched_str="$(cat /sys/block/${bdev}/queue/scheduler)"

	# No brackets if only a single scheduler is available
	if [ "$sched_str" == "none" ]; then
		echo "$sched_str"
	else
		echo "$sched_str" | sed -r 's/.*\[(.+)\].*/\1/'
	fi
}

function set_scheduler()
{
	local dev="$(realpath $1)"
	local bdev="$(basename ${dev})"
	local sched="$2"

	echo "$sched" > /sys/block/${bdev}/queue/scheduler
}

function dev_cdl_supported()
{
	local dev="$(realpath $1)"

	info="$(cdladm info ${dev} | grep "Command duration limits" | head -1)"
	echo "${info}" | grep -c supported
}

function kernel_cdl_supported()
{
        local dev="$(realpath $1)"

	info="$(cdladm info ${dev} | grep "Command duration limits" | tail -1)"
	echo "${info}" | grep -c supported
}

function cdl_enabled()
{
	local dev="$(realpath $1)"
	local bdev="$(basename ${dev})"

	cat /sys/block/${bdev}/device/cdl_enable
}

function enable_cdl()
{
	local dev="$(realpath $1)"
	local bdev="$(basename ${dev})"

	echo "1" > /sys/block/${bdev}/device/cdl_enable
}

function disable_cdl()
{
	local dev="$(realpath $1)"
	local bdev="$(basename ${dev})"

	echo "0" > /sys/block/${bdev}/device/cdl_enable
}

function validate_page()
{
	local dev=$1
	local page_type=$2
	local original_page=$3
	local saved_page="${logdir}/saved_page.cdl"

	cdladm save --page $page_type --file $saved_page $dev || \
		return 1

	diff $original_page $saved_page || \
		return 1

	return 0
}

function require_duration_guideline()
{
	have_dg="$(cdladm info "$1" | grep -c "Command duration guidelines: supported")"
	if [ "${have_dg}" == "0" ]; then
		exit_skip
	fi
}

function fio_get_clat_avg()
{
	local line=$(grep "clat prio $2" "$1" | head -1)
	local avg=$(echo "${line}" | cut -d'=' -f4 | cut -d',' -f1)
	local unit=$(echo "${line}" | cut -d'(' -f2 | cut -d')' -f1)

	if [ "${unit}" == "msec" ]; then
		scale=1000
	elif [ "${unit}" == "usec" ]; then
		scale=1
	else
		scale=0
	fi

	echo "scale=0; ${avg} * ${scale} / 1" | bc
}

function fio_has_io_error()
{
	[ "$(grep -c "func=io_u error" $1)" != 0 ]
}

function fio_get_io_error()
{
	local err="$(grep ", err=" $1)"

	if [ -z "${err}" ]; then
		echo "0"
		exit 0
	fi

	echo "${err}" | cut -d'=' -f3 | cut -d'/' -f1
}

function dev_qd()
{
	local rdev="$(realpath $1)"
	local bdev="$(basename ${rdev})"

	cat /sys/block/${bdev}/device/queue_depth
}

function set_qd()
{
	local rdev="$(realpath $1)"
	local bdev="$(basename ${rdev})"
	local qd="$2"

	if [ "$(dev_qd ${rdev})" == "${qd}" ]; then
		return 0
	fi

	if [ "$qd" != "1" ]; then
		echo 1 > /sys/block/${bdev}/device/queue_depth
		echo "${qd}" > /sys/block/${bdev}/device/queue_depth
	else
		echo 1 > /sys/block/${bdev}/device/queue_depth
	fi
}

function enable_ncq()
{
	set_qd "$1" 32
}

function disable_ncq()
{
	set_qd "$1" 1
}

function test_setup()
{
	local dev="$1"
	local original_T2A="$2"
	local original_T2B="$3"
	local expect_error="$4"
	local compare_latencies="$5"
	local ncq="$6"
	local rw="$7"

	# It does not make sense to compare latencies when expecting an error, as such
	# test cases are expected to exit before reaching the supplied fio runtime.
	if [ "$expect_error" == "1" ] && [ "$compare_latencies" == "1" ]; then
		exit_failed " --> FAILED (invalid test case configuration)"
	fi

	# We only support rw=randread and rw=randwrite for now
	if [ "$rw" != "randread" ] && [ "$rw" != "randwrite" ]; then
		exit_failed " --> FAILED (invalid test case configuration)"
	fi

	# Skip non-NCQ tests on SCSI
	if [ "$ncq" == "0" ] && ! dev_is_ata "$dev"; then
		exit_skip
	fi

	# Only perform queue depth changes if ATA
	if dev_is_ata "$dev"; then
		if [ "$ncq" == "1" ]; then
			enable_ncq "$dev"
			echo "NCQ Enabled (Max QD=$(dev_qd "${dev}"))"
		else
			disable_ncq "$dev"
			echo "NCQ Disabled (Max QD=$(dev_qd "${dev}"))"
		fi
	fi

	# Only upload if page it differs from the existing page
	validate_page $dev T2A $original_T2A || {
		echo "Uploading T2A page"
		cdladm upload --file $original_T2A $dev || \
			exit_failed " --> FAILED to upload T2A page"

		validate_page $dev T2A $original_T2A || \
			exit_failed " --> FAILED to validate uploaded T2A page"
	}

	# Only upload if page it differs from the existing page
	validate_page $dev T2B $original_T2B || {
		echo "Uploading T2B page"
		cdladm upload --file $original_T2B $dev || \
			exit_failed " --> FAILED to upload T2B page"

		validate_page $dev T2B $original_T2B || \
			exit_failed " --> FAILED to validate uploaded T2B page"
	}

	enable_cdl $dev || exit_failed " --> FAILED to enable CDL"
}

function fio_run_time()
{
	local expect_error="$1"

	# If we expect error, we want to have a short run time. We should still get an
	# error in this shorter run time. Having a longer test time when we expect an
	# error is actually LESS reliable, as we might get the error first after e.g.
	# 59 seconds (when the run time would be 60 seconds).
	#
	# When we don't expect error, we want to have a long run time, such that we can
	# be more confident that we do not encounter an error when it is not expected.

	if [ "$expect_error" == "1" ]; then
		echo "10"
	else
		if [ "$quick_tests" == "1" ]; then
			echo "10"
		else
			echo "60"
		fi
	fi
}

function time_cmdline()
{
	# format is not supported in the built-in time command
	local time_bin=$(type -P time)

	echo "$time_bin -f 'CDL_REAL_RUNTIME: %e' -- "
}

function fio_common_cmdline()
{
	local dev="$1"
	local filename="$2"
	local testname="$3"
	local cdl_dld="$4"
	local expect_error="$5"
	local compare_latencies="$6"
	local rw="$7"
	local fiocmd=$(time_cmdline)

	fiocmd+="fio --name=\"$testname\""
	fiocmd+=" --filename=$dev"
	fiocmd+=" --random_generator=tausworthe64"
	fiocmd+=" --write_lat_log=${logdir}/$(test_num $filename)_lat.log"
	fiocmd+=" --log_prio=1 --per_job_logs=0"
	fiocmd+=" --rw=$rw --ioengine=io_uring --iodepth=32"
	fiocmd+=" --bs=512k --direct=1"
	fiocmd+=" --runtime=$(fio_run_time $expect_error)"
	fiocmd+=" --cmdprio_class=2 --cmdprio_hint=$cdl_dld"

	if [ "$compare_latencies" == "1" ]; then
		fiocmd+=" --cmdprio_percentage=10 --ramp_time=10"
	else
		fiocmd+=" --cmdprio_percentage=100"
	fi

	fiocmd+=" 2>&1"

	echo $fiocmd
}

function analyze_log()
{
	local fiolog="$1"
	local expect_error="$2"
	local compare_latencies="$3"
	local cdl_dld="$4"
	local real_runtime
	local max_runtime

	real_runtime="$(grep "CDL_REAL_RUNTIME: " $fiolog)"
	if [ -z "$real_runtime" ]; then
		exit_failed " --> FAILED (real runtime not seen in fio log)"
	fi

	real_runtime=${real_runtime#CDL_REAL_RUNTIME: }

	max_runtime=$(fio_run_time $expect_error)
	# If comparing latencies, we also have a ramptime of 10 seconds
	if [ "$compare_latencies" == "1" ]; then
		max_runtime=$((max_runtime + 10))
	fi

	# Add a 2 second buffer on top of the max time fio is supposed to run,
	# to account for the time it takes to start and exit the binary.
	# We need a small buffer so that we do not accidentally fail test cases
	# that are expected to run the whole run time.
	max_runtime=$((max_runtime + 2))

	# If fio ran longer than max_runtime, then most likely an I/O timed out
	# and the HBA had to be hard reset. This would suggest a FW issue.
	# This check tries to catch such cases, so that we don't accidentally
	# PASS a test case which had I/O timeouts.
	if [ $(echo "$real_runtime > $max_runtime" | bc) -gt 0 ]; then
		exit_failed " --> FAILED (fio ran longer than specified)"
	fi

	if [ "$expect_error" == "1" ]; then
		# We should have IO errors
		if ! fio_has_io_error "${fiolog}"; then
			exit_failed " --> FAILED (fio did not see any IO error)"
		fi

		# IO errors should be 62 (ETIME)
		errno="$(fio_get_io_error ${fiolog})"
		if [ "${errno}" != "62" ]; then
			exit_failed " --> FAILED (fio saw error ${errno} instead of ETIME=62)"
		fi
	else
		# We should not have any IO error
		if fio_has_io_error "${fiolog}"; then
			exit_failed " --> FAILED (IO errors detected, we should not have any)"
		fi
	fi

	if [ "$compare_latencies" == "1" ]; then
		# Get IO completion average latencies and issue a warning if we do not
		# detect sufficient difference between cdl vs no-cdl latencies
		nocdl=$(fio_get_clat_avg "${fiolog}" "0/0/0")
		cdl=$(fio_get_clat_avg "${fiolog}" "2/0/${cdl_dld}")

		echo "Average latency: no-cdl=${nocdl}, cdl=${cdl}"

		thresh=$(( nocdl / 2 ))
		if [ ${cdl} -gt ${thresh} ]; then
			exit_warning " --> WARNING: bad average latency"
		fi
	fi
}

function execute_test()
{
	local testname="$1"
	local T2A_file="$2"
	local T2B_file="$3"
	local cdl_dld="$4"
	local expect_error="$5"
	local compare_latencies="$6"
	local filename="$7"
	local dev="$8"
	local ncq="$9"
	local rw="${10}"

	if [ $# -ne 10 ]; then
		exit_failed " --> FAILED (incorrect number of arguments given)"
	fi

	test_setup "${dev}" \
		"${T2A_file}" "${T2B_file}" \
		"${expect_error}" "${compare_latencies}" \
		"${ncq}" "${rw}" || \
		exit_failed " --> FAILED (error during setup)"

	# fio command
	fiocmd=$(fio_common_cmdline "${dev}" "${filename}" \
		"${testname}" "${cdl_dld}" "${expect_error}" \
		"${compare_latencies}" "${rw}")

	echo "Running fio:"
	fiolog="${logdir}/$(test_num $filename)_fio.log"
	echo "${fiocmd}"
	eval ${fiocmd} | tee "${fiolog}" || exit_failed " --> FAILED"

	analyze_log "${fiolog}" "${expect_error}" \
		"${compare_latencies}" "${cdl_dld}" || \
		exit_failed " --> FAILED (error while analyzing fio log)"
}
