From 14ff44417f1d12a674dd1ff1259f9de697513c54 Mon Sep 17 00:00:00 2001
From: Damien Le Moal <damien.lemoal@wdc.com>
Date: Fri, 10 Sep 2021 17:36:15 +0900
Subject: [PATCH 2/2] libaio,io_uring: Add the cmdprio_split option

Allow a job to execute priority I/Os with different levels by defining a
percentage for each level to use. The percentage applies only to the
percentage of all I/Os that will be executed with an IO priority. For
example, to execute 10% of I/Os with clas 4 and level 1 and 20% of I/Os
with class 4 and level 2, the following options can be used:
	--cmdprio_percentage=30
	--cmdprio_class=4
	--cmdprio_split=1/33:2/67

Work in progress. This completely messes up the clat stats for high/low
priorities as now more than 2 priority levels can be used per job. The
clat accounting and final statistics display must be done per priority
level, for all levels used.

Signed-off-by: Damien Le Moal <damien.lemoal@wdc.com>
---
 engines/cmdprio.h  | 101 +++++++++++++++++++++++++++++++++++++++++++++
 engines/io_uring.c |  28 ++++++++++++-
 engines/libaio.c   |  28 ++++++++++++-
 3 files changed, 155 insertions(+), 2 deletions(-)

diff --git a/engines/cmdprio.h b/engines/cmdprio.h
index 0edc4365..31983dea 100644
--- a/engines/cmdprio.h
+++ b/engines/cmdprio.h
@@ -14,6 +14,8 @@ struct cmdprio {
 	unsigned int level[DDIR_RWDIR_CNT];
 	unsigned int bssplit_nr[DDIR_RWDIR_CNT];
 	struct bssplit *bssplit[DDIR_RWDIR_CNT];
+	unsigned int levelsplit_nr[DDIR_RWDIR_CNT];
+	struct priosplit *levelsplit[DDIR_RWDIR_CNT];
 };
 
 static int fio_cmdprio_bssplit_ddir(struct thread_options *to, void *cb_arg,
@@ -78,6 +80,78 @@ static int fio_cmdprio_bssplit_parse(struct thread_data *td, const char *input,
 	return ret;
 }
 
+struct priosplit {
+        uint32_t prio;
+        uint32_t perc;
+};
+
+static int fio_cmdprio_levelsplit_ddir(struct thread_options *to, void *cb_arg,
+				       enum fio_ddir ddir, char *str, bool data)
+{
+	struct cmdprio *cmdprio = cb_arg;
+	struct split split;
+	unsigned int i;
+
+	if (ddir == DDIR_TRIM)
+		return 0;
+
+	memset(&split, 0, sizeof(split));
+
+	if (split_parse_ddir(to, &split, str, data, BSSPLIT_MAX))
+		return 1;
+	if (!split.nr)
+		return 0;
+
+	cmdprio->levelsplit_nr[ddir] = split.nr;
+	cmdprio->levelsplit[ddir] =
+		malloc(split.nr * sizeof(struct priosplit));
+	if (!cmdprio->levelsplit[ddir])
+		return 1;
+
+	for (i = 0; i < split.nr; i++) {
+		if (split.val1[i] > IOPRIO_MAX_PRIO)
+			cmdprio->levelsplit[ddir][i].prio = IOPRIO_MAX_PRIO;
+		else
+			cmdprio->levelsplit[ddir][i].prio = split.val1[i];
+
+		if (split.val2[i] == -1U)
+			cmdprio->levelsplit[ddir][i].perc = 0;
+		else if (split.val2[i] > 100)
+			cmdprio->levelsplit[ddir][i].perc = 100;
+		else
+			cmdprio->levelsplit[ddir][i].perc = split.val2[i];
+	}
+
+	return 0;
+}
+
+static int fio_cmdprio_levelsplit_parse(struct thread_data *td,
+					const char *input,
+					struct cmdprio *cmdprio)
+{
+	char *str, *p;
+	int i, ret = 0;
+
+	p = str = strdup(input);
+
+	strip_blank_front(&str);
+	strip_blank_end(str);
+
+	ret = str_split_parse(td, str, fio_cmdprio_levelsplit_ddir,
+			      cmdprio, false);
+
+	if (parse_dryrun()) {
+		for (i = 0; i < DDIR_RWDIR_CNT; i++) {
+			free(cmdprio->levelsplit[i]);
+			cmdprio->levelsplit[i] = NULL;
+			cmdprio->levelsplit_nr[i] = 0;
+		}
+	}
+
+	free(p);
+	return ret;
+}
+
 static inline int fio_cmdprio_percentage(struct cmdprio *cmdprio,
 					 struct io_u *io_u)
 {
@@ -101,6 +175,33 @@ static inline int fio_cmdprio_percentage(struct cmdprio *cmdprio,
 	return 0;
 }
 
+static inline int fio_cmdprio_level(struct thread_data *td,
+				    struct cmdprio *cmdprio,
+				    struct io_u *io_u)
+{
+	enum fio_ddir ddir = io_u->ddir;
+	uint64_t r, perc = 0;
+	int i;
+
+	if (!cmdprio->levelsplit_nr[ddir])
+		return cmdprio->level[ddir];
+
+	r = rand_between(&td->prio_state, 0, 99);
+
+	for (i = 0; i < cmdprio->levelsplit_nr[ddir]; i++) {
+		struct priosplit *psp = &cmdprio->levelsplit[ddir][i];
+
+		if (!psp->perc)
+			continue;
+
+		perc += psp->perc;
+		if (r < perc)
+			return psp->prio;
+	}
+
+	return 0;
+}
+
 static int fio_cmdprio_init(struct thread_data *td, struct cmdprio *cmdprio,
 			    bool *has_cmdprio)
 {
diff --git a/engines/io_uring.c b/engines/io_uring.c
index 27a4a678..a24b02cf 100644
--- a/engines/io_uring.c
+++ b/engines/io_uring.c
@@ -115,6 +115,15 @@ static int str_cmdprio_bssplit_cb(void *data, const char *input)
 	return fio_cmdprio_bssplit_parse(td, input, cmdprio);
 }
 
+static int str_cmdprio_levelsplit_cb(void *data, const char *input)
+{
+	struct ioring_options *o = data;
+	struct thread_data *td = o->td;
+	struct cmdprio *cmdprio = &o->cmdprio;
+
+	return fio_cmdprio_levelsplit_parse(td, input, cmdprio);
+}
+
 static struct fio_option options[] = {
 	{
 		.name	= "hipri",
@@ -180,6 +189,16 @@ static struct fio_option options[] = {
 		.category = FIO_OPT_C_ENGINE,
 		.group	= FIO_OPT_G_IOURING,
 	},
+	{
+		.name   = "cmdprio_split",
+		.lname  = "Priority level percentage split",
+		.type   = FIO_OPT_STR_ULL,
+		.cb     = str_cmdprio_levelsplit_cb,
+		.off1   = offsetof(struct ioring_options, cmdprio.levelsplit),
+		.help   = "Set priority level percentages for high priority I/Os",
+		.category = FIO_OPT_C_ENGINE,
+		.group	= FIO_OPT_G_IOURING,
+	},
 #else
 	{
 		.name	= "cmdprio_percentage",
@@ -205,6 +224,12 @@ static struct fio_option options[] = {
 		.type	= FIO_OPT_UNSUPPORTED,
 		.help	= "Your platform does not support I/O priority classes",
 	},
+		{
+		.name   = "cmdprio_split",
+		.lname  = "Priority level percentage split",
+		.type	= FIO_OPT_UNSUPPORTED,
+		.help	= "Your platform does not support I/O priority classes",
+	},
 #endif
 	{
 		.name	= "fixedbufs",
@@ -452,8 +477,9 @@ static void fio_ioring_prio_prep(struct thread_data *td, struct io_u *io_u)
 	struct cmdprio *cmdprio = &o->cmdprio;
 	enum fio_ddir ddir = io_u->ddir;
 	unsigned int p = fio_cmdprio_percentage(cmdprio, io_u);
+	unsigned int cmdprio_level = fio_cmdprio_level(td, cmdprio, io_u);
 	unsigned int cmdprio_value =
-		ioprio_value(cmdprio->class[ddir], cmdprio->level[ddir]);
+		ioprio_value(cmdprio->class[ddir], cmdprio_level);
 
 	if (p && rand_between(&td->prio_state, 0, 99) < p) {
 		sqe->ioprio = cmdprio_value;
diff --git a/engines/libaio.c b/engines/libaio.c
index dd655355..b68b02e2 100644
--- a/engines/libaio.c
+++ b/engines/libaio.c
@@ -71,6 +71,15 @@ static int str_cmdprio_bssplit_cb(void *data, const char *input)
 	return fio_cmdprio_bssplit_parse(td, input, cmdprio);
 }
 
+static int str_cmdprio_levelsplit_cb(void *data, const char *input)
+{
+	struct libaio_options *o = data;
+	struct thread_data *td = o->td;
+	struct cmdprio *cmdprio = &o->cmdprio;
+
+	return fio_cmdprio_levelsplit_parse(td, input, cmdprio);
+}
+
 static struct fio_option options[] = {
 	{
 		.name	= "userspace_reap",
@@ -136,6 +145,16 @@ static struct fio_option options[] = {
 		.category = FIO_OPT_C_ENGINE,
 		.group	= FIO_OPT_G_LIBAIO,
 	},
+	{
+		.name   = "cmdprio_split",
+		.lname  = "Priority level percentage split",
+		.type   = FIO_OPT_STR_ULL,
+		.cb     = str_cmdprio_levelsplit_cb,
+		.off1   = offsetof(struct libaio_options, cmdprio.levelsplit),
+		.help   = "Set priority level percentages for high priority I/Os",
+		.category = FIO_OPT_C_ENGINE,
+		.group	= FIO_OPT_G_LIBAIO,
+	},
 #else
 	{
 		.name	= "cmdprio_percentage",
@@ -161,6 +180,12 @@ static struct fio_option options[] = {
 		.type	= FIO_OPT_UNSUPPORTED,
 		.help	= "Your platform does not support I/O priority classes",
 	},
+	{
+		.name   = "cmdprio_split",
+		.lname  = "Priority level percentage split",
+		.type	= FIO_OPT_UNSUPPORTED,
+		.help	= "Your platform does not support I/O priority classes",
+	},
 #endif
 	{
 		.name	= "nowait",
@@ -211,8 +236,9 @@ static void fio_libaio_prio_prep(struct thread_data *td, struct io_u *io_u)
 	struct cmdprio *cmdprio = &o->cmdprio;
 	enum fio_ddir ddir = io_u->ddir;
 	unsigned int p = fio_cmdprio_percentage(cmdprio, io_u);
+	unsigned int cmdprio_level = fio_cmdprio_level(td, cmdprio, io_u);
 	unsigned int cmdprio_value =
-		ioprio_value(cmdprio->class[ddir], cmdprio->level[ddir]);
+		ioprio_value(cmdprio->class[ddir], cmdprio_level);
 
 	if (p && rand_between(&td->prio_state, 0, 99) < p) {
 		io_u->ioprio = cmdprio_value;
-- 
2.31.1

