From c3d533b5a73bfdd59f78583ceec3f276b73a74fc Mon Sep 17 00:00:00 2001
From: Damien Le Moal <damien.lemoal@wdc.com>
Date: Thu, 4 Nov 2021 17:32:54 +0900
Subject: [PATCH 32/32] scsi: sd: handle command duration limit timeout
 failures

Commands using a duration limit descriptors that has policies other than
0x0 may be failed if one of the duration limit is exceeded. For such
commands, since the failure is the result of the user duration limit
configuration and use of the feature, do not retry the faile commands
and return the timeout error to the user.

This control is implemented with the sd_cdl_complete() helper function.
This function identifies command failures due to duration limit timeout
and for such failure, sets the REQ_FAILFAST_DEV and RQF_QUIET flags for
the command request and the result host byte to DID_TIME_OUT. For this
result to be converted to a BLK_STS_TIMEOUT (and then to a -ETIMEDOUT
for the user), scsi_result_to_blk_status() is modified.

This command post processing is done only for commands that have DLD
bits set. This is identified by using the new scsi command flag
SCMD_HAS_DLD.

Scsi prototype header is also updated to add the definition for the
COMPLETED scsi sense key.

Signed-off-by: Damien Le Moal <damien.lemoal@wdc.com>
---
 drivers/scsi/scsi_lib.c   |  3 ++
 drivers/scsi/sd.c         |  3 ++
 drivers/scsi/sd.h         |  3 ++
 drivers/scsi/sd_cdl.c     | 84 +++++++++++++++++++++++++++++++++++++++
 include/scsi/scsi_cmnd.h  |  2 +
 include/scsi/scsi_proto.h |  2 +-
 6 files changed, 96 insertions(+), 1 deletion(-)

diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index 75c914cf1738..311324831f02 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -643,6 +643,9 @@ static blk_status_t scsi_result_to_blk_status(struct scsi_cmnd *cmd, int result)
 	case DID_MEDIUM_ERROR:
 		set_host_byte(cmd, DID_OK);
 		return BLK_STS_MEDIUM;
+	case DID_TIME_OUT:
+		set_host_byte(cmd, DID_OK);
+		return BLK_STS_TIMEOUT;
 	default:
 		return BLK_STS_IOERR;
 	}
diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c
index 973c2cb2451c..97b84222635b 100644
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -2146,6 +2146,9 @@ static int sd_done(struct scsi_cmnd *SCpnt)
 	if (sd_is_zoned(sdkp))
 		good_bytes = sd_zbc_complete(SCpnt, good_bytes, &sshdr);
 
+	if (sd_cdl_enabled(sdkp) && (SCpnt->flags & SCMD_HAS_DLD))
+		good_bytes = sd_cdl_complete(SCpnt, good_bytes, &sshdr);
+
 	SCSI_LOG_HLCOMPLETE(1, scmd_printk(KERN_INFO, SCpnt,
 					   "sd_done: completed %d of %d bytes\n",
 					   good_bytes, scsi_bufflen(SCpnt)));
diff --git a/drivers/scsi/sd.h b/drivers/scsi/sd.h
index b65b7f2136cf..c307332538eb 100644
--- a/drivers/scsi/sd.h
+++ b/drivers/scsi/sd.h
@@ -343,4 +343,7 @@ static inline bool sd_cdl_enabled(struct scsi_disk *sdkp)
 	return sdkp->cdl && sdkp->cdl_enabled;
 }
 
+unsigned int sd_cdl_complete(struct scsi_cmnd *cmd, unsigned int good_bytes,
+			     struct scsi_sense_hdr *sshdr);
+
 #endif /* _SCSI_DISK_H */
diff --git a/drivers/scsi/sd_cdl.c b/drivers/scsi/sd_cdl.c
index a26135be8cdd..47bea132f527 100644
--- a/drivers/scsi/sd_cdl.c
+++ b/drivers/scsi/sd_cdl.c
@@ -11,6 +11,7 @@
 
 #include <scsi/scsi.h>
 #include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_eh.h>
 
 #include "sd.h"
 
@@ -891,6 +892,7 @@ void sd_cdl_setup_rw16(struct scsi_disk *sdkp, struct scsi_cmnd *scmd)
 	/* Set the DLD bits */
 	scmd->cmnd[1] |= (dld >> 2) & 0x01;
 	scmd->cmnd[14] |= (dld << 6) & 0xc0;
+	scmd->flags |= SCMD_HAS_DLD;
 }
 
 void sd_cdl_setup_rw32(struct scsi_disk *sdkp, struct scsi_cmnd *scmd)
@@ -918,4 +920,86 @@ void sd_cdl_setup_rw32(struct scsi_disk *sdkp, struct scsi_cmnd *scmd)
 
 	/* Set the DLD bits */
 	scmd->cmnd[11] |= dld & 0x07;
+	scmd->flags |= SCMD_HAS_DLD;
+}
+
+/**
+ * sd_cdl_complete - Post processing of commands with DLD set.
+ * @cmd: Completed command
+ * @good_bytes: Command reply bytes
+ * @sshdr: command sense header
+ *
+ * Called from sd_done() to handle failed commands with a duration limit
+ * index set (DLD bits).
+ */
+unsigned int sd_cdl_complete(struct scsi_cmnd *cmd, unsigned int good_bytes,
+			     struct scsi_sense_hdr *sshdr)
+{
+	struct request *rq = cmd->request;
+	int result = cmd->result;
+	bool sense_deferred = false;
+	bool sense_valid;
+
+	if (status_byte(result) == CHECK_CONDITION) {
+		/*
+		 * All timeout failures are signaled with an aborted command
+		 * sense key. So ignore all other errors (sd_done took care of
+		 * these already).
+		 */
+		if (sshdr->sense_key != ABORTED_COMMAND)
+			return good_bytes;
+
+		/*
+		 * Several cases are possible here:
+		 * - max active time policy 0xE may trigger COMMAND TIMEOUT
+		 *   DURING PROCESSING or COMMAND TIMEOUT DURING PROCESSING
+		 *   DUE TO ERROR RECOVERY.
+		 * - max active time policy 0xF may trigger COMMAND TIMEOUT
+		 *   DURING PROCESSING
+		 * - max inactive time and command duration guideline
+		 *   policy 0xF may trigger COMMAND TIMEOUT BEFORE PROCESSING.
+		 */
+		if (sshdr->asc == 0x2e &&
+		    sshdr->ascq >= 0x01 && sshdr->ascq <= 0x03)
+			goto timeout;
+
+		return good_bytes;
+	}
+
+	if (!scsi_status_is_good(result))
+		return good_bytes;
+
+	/*
+	 * sd_done() does not normalize the sense header if result is 0,
+	 * which may happen for a completion with good status.
+	 */
+	sense_valid = scsi_command_normalize_sense(cmd, sshdr);
+	if (sense_valid)
+		sense_deferred = scsi_sense_is_deferred(sshdr);
+	if (sense_valid || sense_deferred)
+		return good_bytes;
+
+	/*
+	 * For all limits, a command that timeout with the policy 0xD
+	 * is completed with a good status and sense data indicating
+	 * COMPLETED/DATA CURRENTLY UNAVAILABLE.
+	 */
+	if (sshdr->sense_key == COMPLETED &&
+	    sshdr->asc == 0x55 && sshdr->ascq == 0x0a)
+		goto timeout;
+
+	return good_bytes;
+
+timeout:
+	/*
+	 * Report the command failed with a timeout error (the user will see
+	 * -ETIMEDOUT). Ignore partial completions and do not retry the command.
+	 * be quiet about these timeout errors.
+	 */
+	scsi_set_resid(cmd, blk_rq_bytes(rq));
+	set_host_byte(cmd, DID_TIME_OUT);
+	rq->cmd_flags |= REQ_FAILFAST_DEV;
+	rq->rq_flags |= RQF_QUIET;
+
+	return 0;
 }
diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
index 69ade4fb71aa..bc1b3cee8f28 100644
--- a/include/scsi/scsi_cmnd.h
+++ b/include/scsi/scsi_cmnd.h
@@ -58,6 +58,8 @@ struct scsi_pointer {
 #define SCMD_UNCHECKED_ISA_DMA	(1 << 1)
 #define SCMD_INITIALIZED	(1 << 2)
 #define SCMD_LAST		(1 << 3)
+#define SCMD_HAS_DLD		(1 << 3)
+
 /* flags preserved across unprep / reprep */
 #define SCMD_PRESERVED_FLAGS	(SCMD_UNCHECKED_ISA_DMA | SCMD_INITIALIZED)
 
diff --git a/include/scsi/scsi_proto.h b/include/scsi/scsi_proto.h
index c36860111932..8cdcbb6800be 100644
--- a/include/scsi/scsi_proto.h
+++ b/include/scsi/scsi_proto.h
@@ -241,7 +241,7 @@ struct scsi_varlen_cdb_hdr {
 #define ABORTED_COMMAND     0x0b
 #define VOLUME_OVERFLOW     0x0d
 #define MISCOMPARE          0x0e
-
+#define COMPLETED	    0x0f
 
 /*
  *  DEVICE TYPES
-- 
2.31.1

